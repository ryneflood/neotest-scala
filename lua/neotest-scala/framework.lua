-- local utils = require("neotest-scala.utils")
--
-- local M = {}
--
-- TEST_PASSED = "passed" -- the test passed
-- TEST_FAILED = "failed" -- the test failed
-- TEST_SKIPPED = "skipped" -- the test was skipped/ignored
--
-- ---@class neotest-scala.Framework
-- ---@field build_command fun(runner: string, project: string, tree: neotest.Tree, name: string, extra_args: table|string): string[]
-- ---@field get_test_results fun(output_lines: string[]): table<string, string>
-- ---@field match_func nil|fun(test_results: table<string, string>, position_id :string):string|nil
--
-- --- Strip ainsi characters from the string, leaving the rest of the string intact.
-- ---@param s string
-- ---@return string
-- local function strip_ainsi_chars(s)
--     local v = s:gsub("\x1b%[%d+;%d+;%d+;%d+;%d+m", "")
--         :gsub("\x1b%[%d+;%d+;%d+;%d+m", "")
--         :gsub("\x1b%[%d+;%d+;%d+m", "")
--         :gsub("\x1b%[%d+;%d+m", "")
--         :gsub("\x1b%[%d+m", "")
--     return v
-- end
--
-- --- Strip sbt info logging prefix from string.
-- ---@param s string
-- ---@return string
-- local function strip_sbt_info_prefix(s)
--     local v = s:gsub("^%[info%] ", "")
--     return v
-- end
--
-- -- ---@return neotest-scala.Framework
-- -- local function utest_framework()
-- --     -- Builds a test path from the current position in the tree.
-- --     ---@param tree neotest.Tree
-- --     ---@param name string
-- --     ---@return string|nil
-- --     local function build_test_path(tree, name)
-- --         local parent_tree = tree:parent()
-- --         local type = tree:data().type
-- --         if parent_tree and parent_tree:data().type == "namespace" then
-- --             local package = utils.get_package_name(parent_tree:data().path)
-- --             local parent_name = parent_tree:data().name
-- --             return package .. parent_name .. "." .. name
-- --         end
-- --         if parent_tree and parent_tree:data().type == "test" then
-- --             local parent_pos = parent_tree:data()
-- --             return build_test_path(parent_tree, utils.get_position_name(parent_pos)) .. "." .. name
-- --         end
-- --         if type == "namespace" then
-- --             local package = utils.get_package_name(tree:data().path)
-- --             if not package then
-- --                 return nil
-- --             end
-- --             return package .. name
-- --         end
-- --         if type == "file" then
-- --             local test_suites = {}
-- --             for _, child in tree:iter_nodes() do
-- --                 if child:data().type == "namespace" then
-- --                     table.insert(test_suites, child:data().name)
-- --                 end
-- --             end
-- --             if test_suites then
-- --                 local package = utils.get_package_name(tree:data().path)
-- --                 return package .. "{" .. table.concat(test_suites, ",") .. "}"
-- --             end
-- --         end
-- --         if type == "dir" then
-- --             local packages = {}
-- --             local visited = {}
-- --             for _, child in tree:iter_nodes() do
-- --                 if child:data().type == "namespace" then
-- --                     local package = utils.get_package_name(child:data().path)
-- --                     if package and not visited[package] then
-- --                         table.insert(packages, package:sub(1, -2))
-- --                         visited[package] = true
-- --                     end
-- --                 end
-- --             end
-- --             if packages then
-- --                 return "{" .. table.concat(packages, ",") .. "}"
-- --             end
-- --         end
-- --         return nil
-- --     end
-- --
-- --     --- Builds a command for running tests for the framework.
-- --     ---@param runner string
-- --     ---@param project string
-- --     ---@param tree neotest.Tree
-- --     ---@param name string
-- --     ---@param extra_args table|string
-- --     ---@return string[]
-- --     local function build_command(runner, project, tree, name, extra_args)
-- --         local test_path = build_test_path(tree, name)
-- --         -- return build_command_with_test_path(project, runner, test_path, extra_args)
-- --         -- FIXME: obviously this doesn't work
-- --         return { "", "" }
-- --     end
-- --
-- --     ---Get test ID from the test line output.
-- --     ---@param output string
-- --     ---@return string
-- --     local function get_test_id(output)
-- --         local words = vim.split(output, " ", { trimempty = true })
-- --         -- Strip the test success indicator prefix and time taken in ms suffix.
-- --         table.remove(words, 1)
-- --         table.remove(words)
-- --         return table.concat(words, " ")
-- --     end
-- --
-- --     -- Get test results from the test output.
-- --     ---@param output_lines string[]
-- --     ---@return table<string, string>
-- --     local function get_test_results(output_lines)
-- --         local test_results = {}
-- --         for _, line in ipairs(output_lines) do
-- --             line = strip_ainsi_chars(line)
-- --             if vim.startswith(line, "+") then
-- --                 local test_id = get_test_id(line)
-- --                 test_results[test_id] = TEST_PASSED
-- --             elseif vim.startswith(line, "X") then
-- --                 local test_id = get_test_id(line)
-- --                 test_results[test_id] = TEST_FAILED
-- --             end
-- --         end
-- --         return test_results
-- --     end
-- --
-- --     return {
-- --         get_test_results = get_test_results,
-- --         build_command = build_command,
-- --     }
-- -- end
--
-- ---@return neotest-scala.Framework
-- local function munit_framework()
--     -- Builds a test path from the current position in the tree.
--     ---@param tree neotest.Tree
--     ---@param name string
--     ---@return table|nil
--     local function build_test_path(tree, name)
--         local parent_tree = tree:parent()
--         local type = tree:data().type
--
--         if parent_tree and parent_tree:data().type == "namespace" then
--             local package = utils.get_package_name(parent_tree:data().path)
--             local parent_name = parent_tree:data().name
--
--             return {
--                 type = "single",
--                 suites = { package .. parent_name },
--                 parent = parent_name,
--                 package = package,
--                 name = name,
--                 test_path = package .. parent_name .. "." .. name,
--             }
--         end
--         if parent_tree and parent_tree:data().type == "test" then
--             local parent_pos = parent_tree:data()
--             return build_test_path(parent_tree, utils.get_position_name(parent_pos)) .. "." .. name
--         end
--         if type == "namespace" then
--             local package = utils.get_package_name(tree:data().path)
--             if not package then
--                 return nil
--             end
--             -- return package .. name .. ".*"
--             -- FIXME: obviously this doesn't work
--             return {}
--         end
--         if type == "file" then
--             local package = utils.get_package_name(tree:data().path)
--             local test_suites = {}
--             for _, child in tree:iter_nodes() do
--                 if child:data().type == "namespace" then
--                     table.insert(test_suites, package .. child:data().name)
--                 end
--             end
--             if test_suites then
--                 return {
--                     type = type,
--                     package = package,
--                     suites = test_suites,
--                     -- FIXME: is this correct? no idea
--                     parent = test_suites[1],
--                     name = "*",
--                     test_path = "*",
--                 }
--             end
--         end
--         if type == "dir" then
--             -- return "*"
--             -- FIXME: obviously this doesn't work
--             return {}
--         end
--         return nil
--     end
--
--     --- Builds a command for running tests for the framework.
--     ---@param runner string
--     ---@param project string
--     ---@param tree neotest.Tree
--     ---@param name string
--     ---@param extra_args table|string
--     ---@return string[]
--     local function build_command(runner, project, tree, name, extra_args)
--         local test_path = build_test_path(tree, name)
--         local parent = test_path.parent
--         local package = test_path.package
--         -- local name = test_path.name
--         -- local test_path = test_path.test_path
--
--         return build_command_with_test_path(
--             project,
--             runner,
--             package,
--             parent,
--             test_path.test_path,
--             test_path,
--             extra_args
--         )
--     end
--
--     ---Get test ID from the test line output.
--     ---@param output string
--     ---@return string
--     local function get_test_name(output, prefix)
--         return output:match("^" .. prefix .. " (.*) %d*%.?%d+s.*") or nil
--     end
--
--     ---Get test namespace from the test line output.
--     ---@param output string
--     ---@return string|nil
--     local function get_test_namespace(output)
--         local o = output:match("^([0-9]+):%s*") or nil
--
--         if o then
--             return nil
--         else
--             return output:match("^([%w%.]+):") or nil
--         end
--     end
--
--     local function take_until(lines, predicate)
--         -- Result table to store lines that satisfy the criteria
--         local result = {}
--
--         -- Iterate over each line in the input table
--         for _, line in ipairs(lines) do
--             -- Check if the predicate returns true for the current line
--             if predicate(line) then
--                 -- If predicate returns true, break the loop
--                 break
--             end
--             -- Otherwise, insert the current line into the result table
--             table.insert(result, line)
--         end
--
--         -- Return the accumulated result when the loop is done
--         return result
--     end
--
--     local function isEmpty(t)
--         return next(t) == nil
--     end
--
--     local function split_lines_by_predicate(lines, predicate)
--         -- Create a table to store the chunks
--         local chunks = {}
--         -- Create a temporary table to accumulate lines for the current chunk
--         local current_chunk = {}
--         local current_chunk_key = nil
--
--         -- Iterate over each line
--         for _, line in ipairs(lines) do
--             -- Check if the predicate condition is met
--             if predicate(line) then
--                 -- Store the current chunk in the chunks table
--                 if current_chunk_key and not isEmpty(current_chunk) then
--                     local chunk_to_insert = { key = current_chunk_key, value = current_chunk }
--                     -- print(vim.inspect(chunk_to_insert))
--                     table.insert(chunks, chunk_to_insert)
--                 end
--
--                 current_chunk_key = line
--                 current_chunk = {}
--             else
--                 if current_chunk_key then
--                     table.insert(current_chunk, line)
--                 end
--             end
--         end
--
--         table.insert(chunks, { key = current_chunk_key, value = current_chunk })
--
--         return chunks
--     end
--
--     -- Get test results from the test output.
--     ---@param output_lines string[]
--     ---@return table<string, string>
--     local function get_test_results(output_lines)
--         local test_results = {}
--
--         local stripped = vim.tbl_map(function(line)
--             return vim.trim(strip_ainsi_chars(line))
--         end, output_lines)
--
--         local lines_without_summary = take_until(stripped, function(line)
--             return line:match("^==================")
--         end)
--
--         local chunks = split_lines_by_predicate(lines_without_summary, function(line)
--             return get_test_namespace(line)
--         end)
--
--         for _, chunk in ipairs(chunks) do
--             local test_namespace = chunk.key
--             -- drop the last character of the line
--             test_namespace = test_namespace:sub(1, -2)
--
--             for _, line in ipairs(chunk.value) do
--                 line = vim.trim(strip_ainsi_chars(line))
--                 if vim.startswith(line, "+") then
--                     local test_name = get_test_name(line, "+")
--                     if test_name then
--                         local test_id = test_namespace .. "." .. vim.trim(test_name)
--                         test_results[test_id] = TEST_PASSED
--                     end
--                 end
--                 if vim.startswith(line, "==> X") then
--                     local test_name = get_test_name(line, "==> X")
--                     test_results[vim.trim(test_name)] = TEST_FAILED
--                 end
--             end
--         end
--
--         print(vim.inspect(test_results))
--
--         return test_results
--     end
--
--     return {
--         get_test_results = get_test_results,
--         build_command = build_command,
--     }
-- end
--
-- ---Returns a framework class.
-- ---@param framework string
-- ---@return neotest-scala.Framework|nil
-- function M.get_framework_class(framework)
--     if framework == "utest" then
--         -- FIXME: obviously this isn't supported right now
--         -- return utest_framework()
--         return nil
--     elseif framework == "munit" then
--         return munit_framework()
--     elseif framework == "scalatest" then
--         -- FIXME: obviously this isn't supported right now
--         -- return scalatest_framework()
--         return nil
--     end
-- end
--
-- function M.build_command_with_test_path(project, runner, package, parent, test_path, dictionary, extra_args)
--     return build_command_with_test_path(project, runner, package, parent, test_path, dictionary, extra_args)
-- end
--
-- return M
